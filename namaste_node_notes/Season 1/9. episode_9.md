Namaste Node
Ep 9 - libuv & Event Loop

1. libuv
    a. Main components in libuv
        1. Event Loop
        2. Callback Queue
        3. Thread Pool
    b. libuv is the main reason for making Node JS aysnchronous and non blocking IO

2. Callback Queues
    a. If JS engine is busy, libuv will hold the callback functions from an async op, it pushes the callback to the callback queue, once the call stack is empty, libuv will offload it to the v8 call stack to execute the callback code
    b. 

3. Event Loop
    a. Prmiary work for event loop is to check both v8 call stack and libuv's callback queue
    b. Once eventloop identifies the v8 call stakc is empty and it checks the callback queue, if there's a callback present, it'll push the callback to the call stack.
    c. In case of race situation, event loop needs to prioritze the order of callback fns to pushed to the call stack and be executed
    
    ---------------------------------------------------
    PHASES IN EVENT LOOP
    1. Phase 1 - timer phase
    2. Phase 2 - poll phase
    3. Phase 3 - check phase
    4. Phase 4 - close phase


    PHASE 1 - timer phase
    1. In this phase, event loop will check if a timer callback (setTimeout, setInterval) is waiting in the queue, eventloop will prioritize the timeout callbacks and send it to the call stack

    PHASE 2 - poll phase
    1. All the callbacks assoicated with IO ops, like reading a file, making http connections, crypto ops etc will be handled in the poll phase
    2. Most of the callbacks will be executed in the poll phase
    3. In ideal state ie, call stack and callback queue are empty, the event loop will wait at the "poll phase"
    4. Sometime peeps refer this as a 'semi infinite loop'
    

    PHASE 3 - check phase
    1. all the callbacks associated with setImmediate will be handled in this check phase

    PHASE 4 - close phase
    1. It's a clean up phase, closing sockets etc

    BEFORE EVERY PHASE, EVENT LOOP WILL EXECUTE the below phase
    1. process.nextTick()
    2. promise callbacks


    *when if the main thread / call stack is empty

    Process
    1. Once the eventloop starts, it'll check the inner circle
        a. check for callbacks for process.nextTick(), if present eventloop sends the callback to the call stack and it'll get executed only *
        b. next, it'll check for any promise callbacks, if present, it'll send it to the call stack for execution, only when *
    2. The eventloop, goes to PHASE A, it'll check for timer callbacks, if any present it'll send the callback to the call stack for execution, only when *
    3. Step 1 is again processes
    4. The eventloop, after the second iteration of the inner process, will go to the poll phase, it''ll check if any callbacks are present, if present it'll send it to the call stack for execution, only when *
    5. Step 1 is processed again
    6. After the third itertion of process.nextTick() and promise callbacks, eventloop will check the setImmediate callbacks in the CHECK PHASE, if any present, it'll send it to the call stack for execution, only when *
    7. Step 1 is processes
    8. After the fourth iteration, event loop will check for any close callbacks in the CLOSE PHASE and send it to the call stack for execution if any found, only when *
    9. One cycle is complete, it'll start running again from Step 1

    Queues
    1. Event loop maintains a priority queue for process.nextTick() and Promise callback
    2. Each phase (timer, poll, check and close) will have a separate queue where the corresponding callbacks will be maintained.
    

    process.nextTick()
    1. process.nextTick() callback has the highest priority and it'll run before every phase in the event loop
    2. if the process.nextTick() has nested process.nextTick(), eventloop will make sure every nested nextTick callback is resolved, and move the next phase only when the nextTick callback queue is empty

    code

    fs.readFile('./file.txt', 'utf8', () => {
        console.log('File Read');
    });

    process.nextTick(() => {
        process.nextTick(()=> console.log('Inner tick'));
        process.nextTick(()=> console.log('Inner tick 2'));
        console.log('1st process.nextTick()');
        Promise.resolve('Promise 2').then(console.log);
    });

    console.log("Last line of the file");

    OP
    Last line of the file
    1st process.nextTick()
    Inner tick
    Inner tick 2
    Promise 2
    File Read