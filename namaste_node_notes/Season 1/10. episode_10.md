Namaste Node
Ep 10 - Thread pool in libuv

1. Is Node JS single threaded or multi threaded 
    a. depends on when? 
        i. if it synchronous code, it's a single threaded
        ii. if it's using libuv for handling async ops, node js is a multi thread
2. for example, when there's a file reading task, v8 will the taask to libuv, libuv make uses in one of the threads in the thread pool, use that thread to establish connection to the OS and do the operation
    a. during this process, the thread is occupied and blocked. Once the operation is complete, thread is freed up
    b. if there's a crypto op, libuv will take up that task, libuv will assign another thread to handle the op, if  other thread is busy handling the fs op
    c. in Node JS, there'a a max limit of 4 threads by default
        UV_THREADPOOL_SIZE = 4 
    d. Let's assume there's 5 operations that libuv is handling
        1. Each op will take up one of the 4 threads to execute the operation
        2. Once one of the ops is done and thread freedup, the 5th and last operation will take up the thread which was freed up bt one of the completed task
3. Below are the operations where thread pool will be used
    File System - fs.readFile, fs.writeFile
    DNS - dns.lookup
    Crypto - crypto.pbkdf2, crypto.scrypt
    Compression	- zlib.gzip, zlib.inflate
4. to handle multiple external requests to a server
    a. any networking ops will happen in sockets
        i. Each socket has a socket descriptor
    b. so if there are 10 users sending request to the server simultaneously, so there'll be 10 threads created to the socket where the user can do read/write ops to the API call via sockets
    c. but what if there are 10000 users, it's an ineffecient method
    c. so in the OS, there are epoll (linux) and kqueue(MacOS) - scalable I/O event notification mechanism
5. whenever there'a network call happening in the OS level, sockets are used to establish connection to perform write/read actions
    a. For each socket, there's a fds (file descriptor) - socket descriptor which will interact / listen with the request made by the user
    b. to handle multiple sockets we can use epoll/kqueue which is in the kernel level
        i.  epoll and kqueue will encapuslate all the fds in the OS,
        ii. it identifies if network activities is happening in one of the fds, if it happens epoll/kqueue will notify to the libuv that API call is happening, libuv will handle the async op and provide the callback to the v8 engine for execution

Things to learn (homework)
1. epoll and kqueue (what DS is epoll and kqueue is using)
    a. epoll uses 'Red Black Tree' Data Structure
2. fds - socket descriptor
3. Event Emitters
4. Streams and buffers
5. Pipes


LEARNINGS
--------------------------------------------------------------------------------------
1. "DON'T BLOCK THE MAIN THREAD" by
    a. using sync methods like crypto.pbkdf2Sync
    b. heavy JSON objects
    c. complex Regex
    d. Complex calculations/loops
2. Data Structure is important!
    a. Timers uses min heap data structure
    b. epoll uses Red Black Tree structure
3. Naming is important
    a. process.nextTick() and setImmediate()
4. There's a lot to learn!