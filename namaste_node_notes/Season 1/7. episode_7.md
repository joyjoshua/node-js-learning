Namaste Node
Episode 7 - sync, async, setTimeoutZero

Ep7 explanation

    //code
    var a = 10;
    var b = 20;

    function multiply(a, b) {
        const result = a * b;
        return result;
    }

    const https = require('https');
    const fs = require('fs');

    https.get("https://api.github.com/users/joyjoshua",
        (res) => {
            console.log('github profile fetched');
    });

    fs.readFile('./file.txt', "utf8", (err, data) => {
        console.log("File Data:", data);
    });

    setTimeout(()=> {
        console.log('timer for 1 second completed')
    }, 1000);


    console.log(multiply(a, b));

1. The above code is a seamless aync non blocking flow, where the v8 offloads async tasks such as http request, timer or file system access operations
2. Other synchronous ops are taken care by the v8

In node we can block the main thread by the following methods
1. using Sync methods of all the async operations
    a. example fs.readFileSync("./file.txt", "utf8"); - this line of code will block the main thread till its execution is complete / This function reads the contents of a file synchronously, meaning it will actually
block the main thread while it’s running.
    b. This Sync method doesn't have a callback, it directly provides the response to v8 in the call stack
    c. It's generally not recommended
    d. Synchronous methods like fs.readFileSync() are still available in Node.js, but
using them can cause performance issues because the code execution will be
halted at that point (e.g., line 7) until the file reading operation is complete.
    e. It best to use the async versions of that methods, ex: fs.readFile() that allow other opes to continue while parallely the file is being read and keeing the app responsive

Crypto module
1. crypto , which is used for cryptographic operations like generating secure keys,
hashing passwords, and more.
2. we can access this module by using the require method 
    const crypto = require('node:crypto'); or
    const crypto = require('crypto');
3. //Password Base Key Derivative Function
crypto.pbkdf2("password", "salt", 500, 50, "sha512", (err, key) => {
    console.log('password key is generated', key);
});
    params for crypto.pbkdf2
    1. Password and Salt: You provide a password and a salt value, which are
combined to create a cryptographic key.
    2. Iterations: You specify the number of iterations (e.g., 50,000) to increase the
complexity of the key, making it harder to crack.
    3. Digest Algorithm: You choose a digest algorithm, like sha512 , which
determines how the key is hashed.
    4. Key Length: You define the length of the key (e.g., 50 bytes).
    5. Callback: In the asynchronous version ( pbkdf2 ), a callback is provided to
handle the result once the key is generated.

Note: When you see Sync at the end of a function name (like pbkdf2Sync ), it means
that the function is synchronous and will block the main thread while it’s
running. This is something you should be cautious about, especially in
performance-sensitive applications.


setTimeout(0)
1. Eventhough the timer has a value of 0, technically the callbacck should be executed immediately, setTimeout(0) will behave differently
2. Only when the call stack / GEC is empty only then the callback function of the timer will get added to the call stack and the code will be executed
3. Reason, as it's a async op, libuv will take the operation execution and wait till the call stack is empty and only then send the timer callback to the call stack for execution
4. More precisily: The callback function from setTimeout(0) is added
to the event queue. However, it won't be executed until the current call stack
is empty. This means that even if you specify a 0-millisecond delay, the
callback will only execute after the global execution context is done
5. Trust Issues with setTimeout(0) :( => When you ask the code to run after 0
milliseconds, it doesn't necessarily run immediately after that time. It runs only
when the call stack is empty. This introduces some "terms and conditions,"
meaning that the actual execution timing is dependent on the state of the call
stack
